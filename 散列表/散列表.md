## 散列表

也称为哈希表，该数据结构提供了键值对的映射关系。通过key快速查找到value，时间复杂度趋近于O(1)。

### 基本原理

散列表在本质上其实也是个数组，但数组只能通过下标访问，散列表是以字符串类型为主的。
将key转换成下标的方法，就称为**哈希函数**

该函数按照数组长度进行取模运算，可得出对应数组的下标。

> 注意: 各个语言实现哈希函数的方法不一，意会一下就行。
>
> HashCode("001121") % Array.length

- 哈希冲突

数组长度优先，随着插入的数据越来越多。不同的hashKey标记的下标可能重复，这就叫哈希冲突。

解决方式有两种: 

1. 开放寻址法

当两个hashKey标记冲突时，让插入的数据在冲突的下标后一个继续寻找可以插入的节点，直到可以插入。

2. 链表法

每一个节点不仅仅存有自己的值，还有一个next指针指向下一个节点。当冲突时, 将冲突的next指针指向新插入的节点。

```
┌───────────┐       ┌───────────┐       ┌───────────┐
│  002182   │──────▶│  002183   │──────▶│  002184   │
└───────────┘       └───────────┘       └───────────┘
      │                                              
      │  [next]                                            
      │                                              
      ▼                                              
┌───────────┐                                        
│ 002182-a  │                                        
└───────────┘                                        
```

### 散列表扩容

当散列表达到一定的饱和度，hashKey的冲突越来越多时，需要扩展长度。

